import sys
import logging
from pathlib import Path
import yaml

from parsers.jenkins_parser import parse_jenkinsfile
from report_generator import generate_report

# Logging setup
LOG_PATH = "logs/conversion.log"
logging.basicConfig(
    filename=LOG_PATH,
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s'
)

def build_run_block(commands):
    """
    Joins a list of shell commands into a YAML multi-line run block.
    """
    if not commands:
        return ""
    if isinstance(commands, str):
        return commands
    return "\n".join(commands)

def prepare_mappings(parsed_data):
    """
    Generate mapping info for reporting.
    """
    mappings = []
    for stage in parsed_data.get("stages", []):
        stage_name = stage.get("name")
        for cmd in stage.get("steps", []):
            converted = f"run: {cmd}"
            mappings.append({
                "stage": stage_name,
                "original": cmd,
                "converted": converted
            })
            logging.info(f"Stage '{stage_name}': {cmd} -> {converted}")
    return mappings

def generate_github_actions_yaml(parsed_data, output_file: Path):
    """
    Create GitHub Actions YAML from Jenkinsfile structure.
    """
    workflow = {
        "name": parsed_data.get("env", {}).get("APP_NAME", "Converted CI Pipeline"),
        "on": {
            "push": {"branches": ["main"]},
            "pull_request": None
        },
        "env": parsed_data.get("env", {}),
        "jobs": {}
    }

    steps = [{"name": "Checkout code", "uses": "actions/checkout@v4"}]

    # Convert each Jenkins stage into a GitHub Actions step
    for stage in parsed_data.get("stages", []):
        name = stage.get("name", "unnamed_stage")
        commands = stage.get("steps", [])
        run_block = build_run_block(commands)

        if not run_block.strip():
            steps.append({"name": name, "run": "echo 'No commands found'"})
        else:
            steps.append({"name": f"{name} Stage", "run": run_block})

    # Add success/failure messages
    app_name = parsed_data.get("env", {}).get("APP_NAME", "Pipeline")
    steps.append({"name": "Success Message", "if": "success()", "run": f'echo "{app_name} completed successfully!"'})
    steps.append({"name": "Failure Message", "if": "failure()", "run": f'echo "{app_name} failed!"'})

    workflow["jobs"]["build"] = {
        "runs-on": "ubuntu-latest",
        "steps": steps
    }

    # Write YAML
    with open(output_file, "w", encoding="utf-8") as f:
        yaml.dump(workflow, f, sort_keys=False)

    logging.info(f"GitHub Actions workflow written to {output_file}")

def run_conversion(input_file: str, output_dir: str = "output"):
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    logging.info(f"Starting conversion: {input_file}")
    print(f"Converting Jenkinsfile: {input_file}")

    parsed = parse_jenkinsfile(input_file)
    if "error" in parsed:
        print(f"❌ Error parsing Jenkinsfile: {parsed['error']}")
        logging.error(parsed["error"])
        return

    mappings = prepare_mappings(parsed)

    output_yaml = output_dir / "converted.yml"
    generate_github_actions_yaml(parsed, output_yaml)

    report_path = Path("reports/conversion_report.txt")
    report_path.parent.mkdir(parents=True, exist_ok=True)

    generate_report(report_path, parsed, mappings, [], output_yaml)

    print(f"✅ Conversion complete!")
    print(f"Output YAML: {output_yaml}")
    print(f"Report: {report_path}")
    print(f"Logs: {LOG_PATH}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python src/converter.py <jenkinsfile> [output_dir]")
        sys.exit(1)
    input_file = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else "output"
    run_conversion(input_file, output_dir)