import os
import json
import logging
from logging.handlers import RotatingFileHandler
from tree_sitter import Language, Parser

# ---------------------------
# Setup Logging
# ---------------------------
LOG_DIR = "logs"
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = os.path.join(LOG_DIR, "unifier_parser.log")

logger = logging.getLogger("UnifierParser")
logger.setLevel(logging.DEBUG)

# File handler (rotating)
file_handler = RotatingFileHandler(LOG_FILE, maxBytes=2_000_000, backupCount=3)
file_handler.setLevel(logging.DEBUG)

# Console handler
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# Formatter
formatter = logging.Formatter(
    "[%(asctime)s] [%(levelname)s] %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
)
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Attach handlers
if not logger.handlers:
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

# ---------------------------
# Load Tree-sitter Language
# ---------------------------
try:
    GROOVY_LANGUAGE = Language("build/my-languages.so", "groovy")
    logger.info("‚úÖ Groovy language loaded successfully.")
except Exception as e:
    logger.error(f"‚ùå Failed to load Groovy language: {e}")
    raise SystemExit(1)


def node_text(source, node):
    return source[node.start_byte:node.end_byte].decode("utf8")


def extract_pipeline_structure(file_path: str):
    """
    Traverses the AST to extract key Jenkinsfile elements:
      - stages
      - steps
      - environment
      - agent
      - post blocks
    """
    logger.info(f"üîç Starting to parse Jenkinsfile: {file_path}")
    if not os.path.exists(file_path):
        logger.error(f"File not found: {file_path}")
        raise FileNotFoundError(file_path)

    with open(file_path, "r") as f:
        source = f.read().encode()

    parser = Parser()
    parser.set_language(GROOVY_LANGUAGE)
    tree = parser.parse(source)
    root = tree.root_node
    logger.debug(f"Root node type: {root.type}")

    pipeline_data = {"stages": [], "environment": {}, "agent": None, "post": {}}

    def walk(node):
        # Detect pipeline declaration
        if node.type == "method_call" and b"pipeline" in source[node.start_byte:node.end_byte]:
            logger.debug(f"Pipeline node detected at {node.start_point}")
            for child in node.children:
                walk(child)

        # Detect stage
        if node.type == "method_call" and b"stage" in source[node.start_byte:node.end_byte]:
            try:
                stage_name = node_text(source, node).split("(")[1].split(")")[0].strip('"\'')
                logger.info(f"üß© Found stage: {stage_name}")
                stage_steps = []
                for sub in node.children:
                    if sub.type == "block":
                        for line in sub.children:
                            if b"sh" in source[line.start_byte:line.end_byte] or b"echo" in source[line.start_byte:line.end_byte]:
                                step_text = node_text(source, line).strip()
                                stage_steps.append(step_text)
                                logger.debug(f"  ‚Ü≥ Step: {step_text}")
                pipeline_data["stages"].append({"name": stage_name, "steps": stage_steps})
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Could not parse stage at {node.start_point}: {e}")

        # Detect environment
        if node.type == "method_call" and b"environment" in source[node.start_byte:node.end_byte]:
            logger.info("üåç Extracting environment variables...")
            block_text = node_text(source, node)
            for line in block_text.split("\n"):
                if "=" in line:
                    key, val = line.split("=", 1)
                    pipeline_data["environment"][key.strip()] = val.strip().strip('"\'')
                    logger.debug(f"  ‚Ü≥ {key.strip()} = {val.strip().strip('\"\'')}")
        for c in node.children:
            walk(c)

    walk(root)
    logger.info("‚úÖ Jenkinsfile parsing complete.")
    return pipeline_data


if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python jenkins_parser_treesitter.py <Jenkinsfile>")
        sys.exit(1)

    try:
        data = extract_pipeline_structure(sys.argv[1])
        output_file = "parsed_output.json"
        with open(output_file, "w") as f:
            json.dump(data, f, indent=4)
        logger.info(f"üìÑ Output saved to {output_file}")
        print(json.dumps(data, indent=4))
    except Exception as e:
        logger.exception(f"‚ùå Parsing failed: {e}")
        sys.exit(1)